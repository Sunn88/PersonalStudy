1. 소프트웨어 공학의 개념
1)  소프트웨어
- 소프트웨어(Software)의 개념
    - 프로그램과, 프로그램의 수행에 필요한 절차, 규칙, 관련 문서 등의 총칭
    - 프로그램 : 컴퓨터를 동작시키고, 어떤 일의 처리 순서와 방법을 지시하는 명령어의 집합
        - 컴퓨터를 통해 일련의 작업을 처리하기 위한 명령어와 관련된 데이터의 집합
    - 자료 구조(Data Structure) : 컴퓨터 기억 장치 내에 자료의 표현, 처리, 저장 방법 등의 총칭
        - 데이터 간의 논리적 관계나 처리 알고리즘
    - 문서(Paper) : 소프트웨어 개발함에 있어 사용자 설명서, 소프트웨어 요구 분석서, 평가서, 명세서, 프로젝트 계획서, 검사 계획서 등을 의미함
- 소프트웨어의 특징
    - 상품성 : 소프트웨어를 개발하면 상품이 되어 판매가 됨
    - 복잡성 : 개발하는 과정이 복잡하고 관리가 어려움
    - 변경 가능성 : 프로그램을 일부 수정하여 업그레이드 및 오류 수정 가능
    - 복제성 : 복제가 용이해 쉽게 복사, 유통이 가능
- 시스템(System)의 개요와 기본 요소
    - 시스템의 개요 : 컴퓨터로 처리 가능한 자료를 입력, 저장, 처리, 가공해 출력할 수 있도록 설계/구현된 정보체계
        하나의 목적을 위해 다양한 요소가 유기적으로 결합된 것
    - ★기본 요소
        - 입력 : 처리 방법, 제어 조건, 처리할 데이터를 시스템에 투입하는 요소
        - 처리 : 입력된 자료를 처리 조건에 따라 변환 및 가공하는 요소
        - 출력 : 처리된 결과를 시스템에서 출력하는 요소
        - 제어 : 시스템의 기본 요소들이 각 과정을 올바르게 행하는지 감독하는 요소
        - 피드백 : 처리된 결과를 측정, 파악하여 목표에 도달되었는가를 검사하며 만일 불충분할 경우 목표 달성을 위해 다시 입력하는 요소
- ★소프트웨어 위기(Software Crisis)
    - 컴퓨터의 발달 과정에서 소프트웨어의 개발 속도가 하드웨어의 개발 속도를 따라가지 못해 사용자들의 요구사항을 감당할 수 없는 문제가 발생함
    - 원인
        - 하드웨어 비용을 초과하는 개발 비용의 증가
        - 개발 기간의 지연
        - 개발 인력 부족 및 인건비 상승
        - 성능 및 신뢰성 부족
        - 유지보수의 어려움에 따른 엄청난 비용
2) 소프트웨어 공학(Software Engineering)
- 소프트웨어 공학의 이해
    - 경제적으로 신뢰도 높은 소프트웨어를 만들기 위한 방법, 도구와 절차들의 체계
    - IEEE(전기전자학회)의 정의 : 소프트웨어의 개발, 운용, 유지보수 및 파기에 대한 체계적인 접근 방법
- ★소프트웨어 공학의 기본 원칙
    - 현대적인 프로그래밍 기술을 적용해야
    - 신뢰성이 높아야
    - 사용의 편리성과 유지보수성이 높아야
    - 지속적인 검증 시행을 해야
    - 결과에 대한 명확한 기록을 유지해야
    - 사용자가 원하는 대로 동작해야
    - 시스템의 안전성과 보안에 만전을 기해야
    - 최신 프로그램 언어, 최신 알고리즘 사용 현황을 확인해야
    - 소프트웨어 개발 비용을 최소화하도록 노력해야
    - 개발 단계와 소스 코드 등의 문서화를 통해 명확성을 유지해야
- 공학적으로 좋은 소프트웨어의 조건
    - 신뢰성이 높고 효율적이어야 하며, 사용자의 의도대로 동작해야
    - 편리성 제공 및 잠재적 에러를 최소화해야
    - 유지보수성이 용이해야
- 소프트웨어 공학 계층 구조
    - 도구 : 프로세스와 방법을 처리하는 기능을 제공
    - 방법론 : 소프트웨어를 설계하는 데 기술적인 방법을 제공
    - 프로세스 : 소프트웨어의 가장 기초 
        - 개발에 사용되는 방법론과 도구가 적용되는 순서
- 소프트웨어 품질
    - 사용자의 요구대로 만들어져야
    - 유지보수가 쉬워야
    - 에러를 최소화해야
    - 초반에 정한 비용에 맞춰 개발해야
    - 정확한 결과가 도출되어야
    - 원하는 시간에 원하는 기능을 수행할 수 있어야
- 소프트웨어 공학의 목표
    - 최소의 비용으로 단기간에 시스템에 적합한 소프트웨어를 개발하는 것
    - 소프트웨어 제품의 품질을 향상시키고 소프트웨어 생산성과 작업 만족도를 증대시키는 것
    - 신뢰성 있는 소프트웨어를 경제적인 비용으로 획득하기 위해 공학적 원리를 정립하고 이를 이용하는 것

2. 재공학
1) 재공학
- 소프트웨어 재공학(Software Reengineering)의 개념 및 목표
    - 소프트웨어 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하려는 방법을 의미
    - 재구조화는 재공학의 한 유형 
        - 사용자의 요구사항이나 기술적 설계의 변경 없이 프로그램을 개선하는 것
    - 예방 유지보수(Preventive Maintenance) : 소프트웨어 재공학 관점에서 가장 연관 깊은 유지보수 유형
    - 재사용을 수월하게 하며 소프트웨어의 수명을 연장하게 위해
- ★재공학의 장점
    - 개발 시간과 비용을 감소시킴
    - 프로젝트 실패의 위험을 감소시킴
    - 소프트웨어의 품질 및 생산성을 향상시킴
    - 구축 방법에 대한 개발 지식을 공유할 수 있음
- 재공학의 과정
    - 분석(Analysis) : 기존 소프트웨어의 명세서를 확인하여 소프트웨어의 동작을 이해하고 재공학 대상을 선정
    - 재구성(Restructuring) : 소프트웨어 구조를 향상시키기 위해 코드를 재구성
    - 역공학(Reverse Engineering) : 원시 코드를 분석하여 소프트웨어 관계를 파악하고 기존 시스템의 설계 정보를 재발견하여 다시 제작하는 작업
    - ★이식(Migration) : 기존 소프트웨어 시스템을 새로운 기술 도는 하드웨어 환경에서 사용할 수 있도록 변환하는 작업
- 재사용의 2가지 기본 기술
    - 생성 중심(Generation Based, 모듈화) : 재사용 단위를 찾아 발전시키는 기술
        - 전자칩 같은 유용한 소프트웨어 부품을 찾아내는 기술
    - 합성 중심(Composition Based, 모델화) : 모듈을 생산성 있게 조립하는 기술
        - 블록(모듈)을 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 기술
- 리팩토링(Refactoring) : 겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것
    -> 소프트웨어를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록
2) CASE(Computer Aided Software Engineering)
- CASE
    - 소프트웨서 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정을 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 작업
    - 자료 흐름도 등의 다이어그램을 쉽게 작성하게 해주는 소프트웨어 도구
    - 작업 과정 및 데이터 공유를 통해 작업자 간의 커뮤니케이션을 증대
- CASE가 제공하는 기능
    - 개발을 신속하게 할 수 있고, 오류 수정이 쉬워 소프트웨어 품질이 향상됨
    - 소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화시켜 주는 통합된 도구를 제공
    - 소프트웨어 시스템의 문서화 및 명세화를 위한 그래픽 기능 제공
    - 소프트웨어 개발 단계의 표준화를 기할 수 있으며 자료 흐름도 작성 기능 제공
    - 모델들 사이의 모순 검사 기능 제공, 다양한 소프트웨어 개발 모형 지원
    - ★원천 기술 : 구조적 기법, 프로토타이핑 기술, 정보 저장소 기술
- CASE 사용의 장점
    - 소프트웨어 개발 기간 단축 및 개발 비용을 절약하여 소프트웨어 생산성 향상시킴
    - 자동화된 검사를 통해 소프트웨어 품질이 향상됨
    - 프로그램의 유지보수가 간편해지고 소프트웨어 모듈의 재사용성이 향상됨
    - 소프트웨어 개발 주기의 표준안 확립, 소프트웨어 개발 기법의 실용화, 문서화의 용이성 제공, 시스템 수정 및 유지보수 축소 등의 효과
- ★CASE의 분류
    - 상위(Upper) CASE : 요구 분석 및 설계 단계 지원(모델 간 모순 검사 기능, 모델 오류 검증 기능, 자료 흐름도 작성 기능)
    - 하위(Lower) CASE : 소스 코드 작성, 테스트, 문서화 과정 지원
    - 통합(Integrate) CASE : 소프트웨어 개발 주기 전체 과정 지원
3) 요구사항 분석을 위한 CASE 도구
- 요구사항 분석을 위한 CASE
    - 요구사항을 자동으로 분석 및 요구사항 분석 명세서를 기술하도록 개발된 도구
    - 표준화와 보고를 통한 문서화 품질 개선, 변경이 주는 영향 추적의 용이성, 명세에 대한 유지보수 비용 축소, 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이성 등의 특징
    - DB를 모두가 이용 가능하다는 점에서 분석자들 간의 적절한 조정 기능 제공
- ★요구사항 분석을 위한 CASE 도구
    - SADT(Structured Analysus and Design Technique) : SoftRech사에서 개발
        - 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위해 널리 이용되어 온 구조적 분석 및 설계 도구
        - 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구
    - SREM(Software Requrements Engineering Methodology) : TRW사에서 개발
        - 우주국방시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발
        - RSL과 REVs를 사용하는 자동화 도구
        - RSL(Requirement Statement Language) : 요소, 속성, 관계 구조들을 기술하는 요구사항 기술 언어
        - REVS(Requirement Engineering and Validation System) : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기
    - PSL/PSA : 미시간 대학에서 개발

3.소프트웨어 개발 방법론
1) 소프트웨어 설계 방법론
- 소프트웨어 생명주기(Software Life Cycle)
    - 소프트웨어 제품의 개념 형성에서 시작, 운용/유지보수에 이르기까지 변화의 모든 과정
    - 타당성 검토->개발 계획->요구사항 분석->설계->구현->테스트->운용->유지보수
- ★폭포수 모형(Waterfall Model)
    - 선형 순차적 모델이라고 불림
    - Bohem이 제시한 고전적 생명주기 모형
    - 소프트웨어 개발 과정의 각 단계가 순차적으로 진행되는 모형
- 나선형 모형(Spiral Model)
    - Bohem이 제시한, 반복적인 작업을 수행하는 점증적 생명주기 모형
    - 점증적 모형, 집중적 모형이라 불리며 유지보수 과정이 필요 없음
    - ★소프트웨어 개발 중 발생할 수 있는 위험을 관리하고 최소화하는 것이 목적
    - 나선을 따라 돌아가면서 각 개발 순서를 반복하여 수행하는 점진적 방식
    - 누락된 요구사항 추가 가능
- ★나선형 모형의 개발 단계
    - 계획 수립 : 기능, 제약 등의 세부적 계획 단계
    - 위험 분석 : 위험 요소 분석 및 해결 방안 설정 단계
    - 개발과 검증 : 기능 개발 및 검증 단계
    - 고객 평가 및 다음 단계 수립 : 결과물 평가 및 추후 단계 진행 여부 결정 단계
- 하향식과 상향식 설계
    - 하향식 설계 : 소프트웨어 설계 시 제일 상위에 있는 Main User Function에서 시작하여 기능을 하위 기능들로 나눠 가면서 설계하는 방식
    - 상향식 설계 : 가장 기본적인 컴포넌트를 먼저 설계한 후 이것을 사용하는 상위 수준의 컴포넌트를 설계하는 방식
- 프로토타입 모형(Prototype Model)
    - 실제 개발될 시스템의 견본을 미리 만들어 최종 결과물을 예측하는 모형
    - 개발이 완료되고 나서 사용을 하면 문제점을 알 수 있는 폭포수 모형의 단점 보완 -> 요구사항을 충실하게 반영
- HIPO(Hierarchy Input Process Output)
    - 입력, 처리, 출력으로 구성되는 시스템 분석 및 설계와 시스템 문서화용 기법
    - 가시적 도표(Visual Table of Contents), 총체적 다이어그램(Overview Diagram), 세부적 다이어그램(Detail Diagram)으로 구성됨
    - 구조도(가시적 도표, 개요, 도표(Index Diagram)), 상세 도표로 구성됨
    - 기능과 자료의 의존 관계를 동시에 표현 가능
    - 보기 쉽고 이해하기 쉬우며 유지보수가 쉬움
    - 하향식 소프트웨어 개발 위한 문서화 도구
- V-모델
    - 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델
    - 세부적인 프로세스로 구성되어 있어 신뢰도 높은 시스템 개발에 효과적
    - 개발 단계의 작업을 확인하기 위해 테스트 작업 수행
    - 생명주기 초반부터 테스트 작업 지원
    - 코드뿐 아니라 요구사항과 설계 결과도 테스트할 수 있어야
    - 폭포수 모형보다 반복과 재처리 과정이 명확함
    - 테스트 작업을 단계별로 구분하므로 책임이 명확해짐
2) 애자일(Agile) 개발 방법론
- 애자일 개발 방법론
    - 특정 방법론이 아닌, 소프트웨어를 빠르고 낭비 없이 제작하기 위해 고객과의 협업에 초점을 둔 것
    - 소프트웨어 개발 중 설계 변경에 신속히 대응하여 요구사항을 수용할 수 있음
    - 절차와 도구보다 개인과 소통을 중요시하고 고객과의 피드백을 중요하게 생각함
    - 소프트웨어가 잘 실행되는데 가치를 두며, 소프트웨어 배포 시차를 최소화할 수 있음
    - 특징 : 짧은 릴리즈와 반복, 점증적 설계, 사용자 참여, 문서 최소화, 비공식적인 커뮤니케이션 변화
    - 원칙
        - 소통 : 알기 쉬운 차트, 정보 공유, 회의
        - 협력 : 개발팀 협조, 고객과의 대화로 문제 해결
        - 적응 : 변화 수용, 융통성 발휘
        - 지속 : 검증을 반복, 점증 개발
        - 가치 전달 : 위험도 높은 작업 우선, 비용 감소
        - 피드백 : 자주 출시, 고객 평가
- Agile 선언문
    - 프로세스나 도구보다 개인과의 소통이 더 중요함
    - 완벽한 문서보다 실행되는 소프트웨어가 더 중요함
    - 계약 협상보다 고객과의 협업이 더 중요함
    - 계획을 따르는 것보다 변경에 대한 응답이 더 중요함
3) XP(eXtreme Programming)
- XP
    - 1999년 Kent Beck이 제안
    - 개발 단계 중 요구사항이 시시각각 변동이 심한 경우 적합한 방법론
    - 요구에 맞는 양질의 소프트웨어를 신속하게 제공하는 것을 목표로 함
    - 요구사항이 변경되는 것을 적용하는 방식으로 예측성보다는 적응성에 더 높은 가치를 부여
    - ★고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상하는 방법
- ★XP 핵심가치
    - 의사소통(Communication) : 개발자, 관리자, 고객 간의 원활한 소통 지향
    - 단순성(Simplicity) : 부가적 기능 또는 미사용 구조와 알고리즘 배재
    - 피드백(Feedback) : 소프트웨어 개발에서의 ㅂ녀화는 지속적 테스트와 통합, 반복적 결합 수정 등 빠르게 피드백
    - 용기(Courage) : 고객 요구사항 변화에 능동적으로 대응
    - 존중(Respect) : 개발 팀원 간의 상호 존중을 기본으로
- XP Process
    - User Story
        - 사용자의 요구사항을 간단한 시나리오로 표현(UML의 Use Case와 목적이 같음)
        - 형식이 없고 고객에 의해 작성됨
    - Release Planning
        - 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품 제공
        - 부분/전체 개발 완료 시점에 대한 일정 수립
    - Iteration
        - 하나의 릴리즈를 세분화한 단위, 1~3주 단위로 진행됨
        - iteration 진행 중 새로운 스토리가 추가될 때 진행 중 iteration이나 다음 iteration에 추가될 수 있음
    - Acceptance Test
        - 릴리즈 단위의 개발이 구현되었을 때 진행되는 테스트
        - 사용자 스토리에 작성된 요구사항을 확인하여 고객이 직접 테스트함
        - 오류가 발견되면 다음 iteration에 추가함
        - 테스트 후 고객의 요구사항이 변경되거나 추가되면 중요도에 따라 우선순위가 변경될 수 있음
        - 완료 후 다음 iteration 진행함
    - Small Release
        - 릴리즈 단위를 기능별로 세분화하면 고객의 반응을 기능별로 확인할 수 있음
        - 최종 완제품일 떄 고객에 의한 최종 테스트 진행 후 고객에게 제공함
- XP의 12가지 실천사항
    - Fine Scale Feedback
        - 1. Pair Programming(짝 프로그래밍) : 하나의 작업을 2명의 개발자가 공동 수행
            - 두 사람이 짝이 되어 한 사람은 코딩을 다른 사람은 검사를 수행하는 방식
            - 코드에 대한 책임을 공유하고, 비형식적인 검토 수행 가능
            - 코드 개선을 위한 리팩토링을 장려하며, 생산성이 떨어지지 않음
        - 2. Planning Game : 게임처럼 선수와 규칙, 목표를 두고 기획에 임함
        - 3. Test Driven Development : 실제 코드를 작성하기 전 단위 테스트부터 작성 및 수행함, 이를 기반으로 코드 작성
        - 4. Whole Team : 개발 효율을 위해 고객을 프로젝트팀원으로 상주시킴
    - Continuous Process
        - 5. Continuous Integration : 상시 빌드 및 배포를 할 수 있는 상태로 유지함
        - 6. Design Omprovement : 기능 변경 없이 중복성/복잡성 제거, 커뮤니케이션 향상, 단순화, 유연성 등을 위한 재구성 수행
        - 7. Small Releases : 짧은 주기로 잦은 릴리즈를 함으로써 고객이 변경사항을 볼 수 있게 함
    - Shared Understanding
        - 8. Coding Standards : 소스 코드 작성 포맷과 규칙들을 표준화된 관례에 따라 작성함
        - 9. Collective Code Ownershio : 시스템에 있는 소스 코드는 팀의 모든 프로그래머가 누구든지 언제라도 수정할 수 있음
        - 10. Simple Design : 가능한 가장 간결한 디자인 상태를 유지함
        - 11. System Metaphor : 최종적으로 개발되어야 할 시스템의 구조를 기술함
    - Programmer Welfare
        - 12. Sustainable Pace : 일주일에 40시간 이상 작업 금지, 2주 ㅇ녀속 오버타임 금지
- 효과적인 프로젝트 관리를 위한 3대 요소
    - 사람(People) : 인적 자원
    - 문제(Problem) : 문제 인식
    - 프로세스(Process) : 작업 계획
- 정형 기술 검토 지침사항
    - 의제와 그 범위를 유지하라
    - 참가자의 수를 제한하라
    - 각 체크 리스트를 작성하고, 자원과 시간 일정을 할당하라
    - 개발자가 아닌 제품의 검토에 집중하라
    - 논쟁과 반박을 제한하라
    - 검토 과정과 결과를 재검토하라

4. SCRUM
1) SCRUM
- SCRUM 개념과 특징
    - 요구사항 변경에 신속하게 대처할 수 있도록 반복적이고 점진적인 소규모 팀원 간 활발한 소통과 협동심히 필요한 팀 중심의 소프트웨어 개발 방법론
    - 신속하게 반복적으로 실제 작동하는 소프트웨어를 제공함
    - 개발자들의 팀 구성과 각 구성원의 역할, 일정 결과물 및 그 외 규칙을 정하는 것
    - 기능 개선점에 우선순위를 부여하고, 개발 주기 동안 실제 동작 가능한 결과를 제공함
    - 개발 주기마다 적용된 기능이나 개선점의 리스트를 제공함
    - 커뮤니케이션을 위하여 팀은 개방된 공간에서 개발하고, 매일 15분 정도 회의함
    - 팀원 스스로 팀을 구성해야함(Self Organizing)
    - 개발 작업에 관한 모든 것을 팀원 스스로 해결해야 함(Cross Functional)
- SCRUM 기본 원리
    - 기능 협업을 기준으로 배치된 팀은 스프린트 단위로 소프트웨어 개발
    - 스프린트는 거정된 30일의 반복, 스프린트시 행하는 작업은 고정됨
    - 요구사항, 아키텍처, 설계가 프로젝트 전반에 걸쳐 잘 드러나야 함
    - 정해진 시간 철저히 지키며, 완료된 모든 작업은 제품 백로그에 기록됨
    - 가장 기본적인 정보 교환 수단은 일일 스탠드 업 미팅, 일일 스크럼
- 스크럼의 5가치
    - 확약 : 약속을 확실히 실현
    - 전념 : 확약을 위해 실현에 전념
    - 정직 : 모든 사실을 숨기지 않음
    - 존중 : 다른 사람에게 경의를 표함
    - 용기 : 옳은 일을 할 수 있도록 갈등과 도전을 극복
- SCRUM팀의 역할
    - 제품 책임자(Product Owner)
        - 개발 목표에 이해도가 높은 개발 의뢰자, 사용자
        - 제품 요구사항 파악, 기능 목록(Pdoduct Backlog) 작성
        - 제품 테스트 수행 및 요구사항 우선순위 갱신
        - 업무 관점 우선순위와 중요도 표시, 신규 항목 추가
        - 스프린트 계획 수립까지만 임무 수행
    - 스크럼 마스터(SCRUM Master)
        - 업무 배분, 팀이 스스로 조직 및 관리하도록 지원
        - 개발 과정에서 장애 요소 찾아 제거
        - 개발 과정에서 스크럼의 원칙과 가치를 지키도록 지원
    - 스크럼 팀(SCRUM Team)
        - 개발자, 디자이너, 제품 테스터 등 모든 팀원, 5~9명 내외로 구성
        - 기능을 작업 단위로 분류, 요구사항을 사용자 스토리로 도출 및 구현
        - 개발 일정, 속도를 추정한 뒤 제품 책임자에게 전달
        - 스프린트 결과물을 제품 책임자에게 시연
        - 매일 스크럼 회의에 참여해 진행 상황을 점검
- 스크럼의 요소
    - 백로그(Backlog) : 제품 기능 목록, 사용자가 요구한 기능에 우선순위를 부여해 나열한 목록
    - 스프린트(Sprint) : 작업량이 많지 않고, 짧은 개발 단위를 단기간 내에 전력으로 개발
    - 스크럼 미팅 : 15분 정도의 팀 미팅, 작업 계획 수립
    - 스크럼 마스터 : 팀리더, 효율적인 개발과 문제 해결을 위해 노력
2) SCRUM  과정
- Product Backlog
    - 제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록
    - 개발 과정에서 새롭게 도출되는 요구사항으로 인해 지속해서 업데이트됨
    - 제품 백로그에 작성된 사용자 스토리를 기반으로 전체 일정 계획인 릴리즈 계획 수립
- Sprint
    - 작은 단위의 개발 업무를 단기간에 전력 질주하여 개발
    - 반복주기(2~4주)마다 이해관계자에게 일의 진척도를 보고
- Spring Planning Meeting
    - 제품 기능 목록(Product Backlog)에서 진행할 항목 선택
    - 선택한 스프린트에 대한 단기 일정 수힙, Task 단위로 나눔
    - 개발자별 Spring Backlog 작성, 결과물에 대한 반복 완료 시 모습 결정
    - 수행에 필요한 요구사항을 스크럼 마스터에게 보고, 이해관계자로부터 지원 받음
- Daily SCRUM Meeting
    - 매일 약속된 시간에 짧은 시간 동안 진행 상황 점검
    - 스크럼 마스터는 방해 요소 찾아 제거, 잔여 작업 시간을 소멸 차트(Burm down Chart)에 기록
- Finished Work : 모든 스프린트 주기가 완료되면, 제품 기능 목록의 개발 목표물이 완성됨
- 스프린트 리뷰(Sprint Review)
    - 스프린트 검토 회의에 개발자와 사용자가 같이 참석
    - 하나의 스프린트 반복 주기(2~4주)가 끝나면 생성된 실행 가능한 제품에 대해 검토, 가능한 4시간 안에 마무리
    - 개선해야 할 사항에 대해 제품 책임자는 피드백을 정리, 제품 백로그 작성, 다음 스프린트에 적용
- 스프린트 회고(Sprint Retrospective)
    - 스프린트에서 수행한 활동과 결과물 살펴보기
    - 개선점 없는지 살펴보고 문제점 기록 정도로 진행
    - 팀의 단점보다 강점을 찾아 팀 능력 극대화
    - 개발 추정 속도와 실제 작업 속도 비교, 차이가 나면 이유 분석

5. 현행 시스템 분석

6. 요구사항 개발

7. UML

8. UI 환경 변수

9. UI 내 표준 및 지침

10. UI 설계