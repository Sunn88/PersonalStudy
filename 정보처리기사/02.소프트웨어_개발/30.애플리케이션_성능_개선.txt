1) 애플리케이션 성능 개선
- 성능을 측정 지표
    - 처리량(Throughput) : 주어진 시간에 처리할 수 있는 프로세스 처리 수
    - 응답 시간(Response Time) : 데이터 입력 완료 시 부터 응답 출력이 개시될 때까지의 시간
    - 경과 시간(Turnaround Time) : 입력한 시점부터 그 결과의 출력이 완료할 때까지 걸리는 시간
    - 자원 사용률(Resource Usage) : 프로세스 처리 중 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량
- 유형별 성능 분석 도구
    - 성능/부하/스트레스(Performance/Load/Stress) 점검 도구 : 측정 지표인 처리량, 응답 시간, 경과 시간 등을 점검하기 위해 가상의 시스템 부하나 스트레스를 통해 성능을 분석하는 도구
    - 모니터링(Monitoring) 도구 : 성능 모니터링, 성능 저하 원인 분석, 시스템 부하량 분석, 장애 진단, 사용자 분석, 용량 산정 등의 기능을 통해 애플리케이션 실행 시 자원 사용량을 확인하고 분석하는 도구
        - 위험 모니터링 : 위험 요소, 징후들에 대해 계속적으로 인지하는 것
- 위험 감시(Risk Monitoring) : 위험 요소 징후들에 대해 계속적으로 인지하는 것
2) 애플리케이션 성능 저하 원인
- ★데이터베이스 연결 및 쿼리 실행 시 발생되는 성능 저하 원인
    - DB Lock
        - 과도한 데이터 조회/업데이트/인덱스 생성 시 발생함
        - Lock의 해제 시까지 대기하거나 처리되지 못하고 종료됨
    - 불필요한 DB fetch
        - 필요한 데이터보다 많은 대량의 데이터 요청이 들어올 경우 발생함
        - 결과 세트에서 마지막 위치로 커서를 옮기는 작업이 빈번한 경우 응답 시간 저하 현상이 발생함
    - 연결 누수(Connection Leak) : DB 연결과 관련한 JDBC 객체를 사용 후 종료하지 않을 경우 발생함
    - 부적절한 Connection Pool Size : 커넥션 풀 크기가 너무 작거나 크게 설정한 경우 발생함
    - 기타 : 트랜잭션이 Commit되지 않고 커넥션 풀에 반환되거나, 잘못 작성된 코드로 인해 불필요한 Commit가 자주 발생하는 경우 발생
- 내부 로직으로 인한 성능 저하 원인
    - 웹 애플리케이션의 인터넷 접속 불량이나 대량의 파일로 인해 부하가 발생하는 경우
    - 정상적으로 처리되지 않은 오류 처리로 인한 부하나 트랜잭션이 수행되는 동안 외부 트랜잭션(외부 호출)이 장시간 수행되거나, 타임아웃이 일어나는 경우
- 잘못된 환경 설정이나 네트워크 문제로 인한 성능 저하 원인
    - 환경 설정으로 인한 성능 저하 : Thread Pool, Heap Memory의 크기를 너무 작게 설정하면 Heap Memory Full 현상이 발생함
    - 네트워크 장비로 인한 성능 저하 : 라우터, L4 스위치 등 네트워크 관련 장비 간 데이터 전송 실패 또는 전송 지연에 따른 데이터 손실이 발생함
3) 알고리즘
- 알고리즘
    - 주어진 과제를 해결하기 위한 방법과 절차를 의미
    - 알고리즘은 자연어, 의사코드, 순서도, 프로그래밍 언어를 이용해 표현 가능
        - 의사코드(Pseudocode) : 특정 프로그래밍 언어의 문법에 따라 쓰인 것이 아니라, 일반적인 언어로 코드를 흉내내 알고리즘을 써놓은 코드
- 알고리즘 설계 기법
    - 분할 정복법(Divide & Conquer)
        - 제시된 문제를 분할이 불가할 때까지 나누고, 각 과제를 풀면서 다시 병합해 문제의 답을 얻응 Top-Down 방식
            - 분할(Divide) : 정복이 필요한 과제를 분할이 가능한 부분까지 분할
            - 정복(Conquer) : 위에서 분할된 하위 과제들을 모두 해결(정복)
            - 결합(Combine) : 위에서 정복된 해답을 모두 취합(결합)
        - ex) 퀵 정렬 알고리즘, 병합(합병) 정렬 알고리즘
    - 동적 계획법(Dynamic Programming)
        - 주어진 문제를 해결하기 위해 부분 문제에 대한 답을 계속적으로 활용해 나가는 Bottom-Up 방식
            - 부분 문제로 분리
            - 가장 낮은 단계의 부분 문제 해답 계산
            - 이 부분 문제의 해답을 이용해 상위 부분 문제를 해결
        - 이전 단계의 해답을 활용하기 위해 반드시 기억할 수 있는 저장소가 필요하기 때문에 속도는 빠르지만, 공간 복잡도가 커지는 단점이 있음
        - ex) 플로이드 알고리즘, 피보나치수열 알고리즘
            - 피보나치수열 알고리즘 : 재귀호출(동적 계획법)뿐만 아니라 분할 정복법을 통해서도 구현 가능
    - 탐욕법(Greedy Method)
        - 국소적인 관점에서 최적의 해결 방법을 구하는 기법으로 최적의 해결 방법을 구하지는 못하나 동적 계획법보다 효율적
        - ex) 크루스칼 알고리즘, 다익스트라 알고리즘
    - 퇴각 검색법(Backtracking)
        - 어떤 문제의 최적해를 구하기 위해 모든 가능성을 찾아가는 방법
        - N-Queen 문제 해결 시 응용됨
            - N-Queen : N*M 체스판에 N개의 퀸을 서로 공격할 수 없게 배치하는 경우의 수를 출력하는 문제
        - 동적 계획법과 같이 기억할 저장소를 필요로 함
    - 분기 한정법(Branch & Bound)
        - 정해진 범위(Bound)를 벗어나는 값들은 가지치기(Branch)해가며 결과값을 추적해 나가는 방식
        - ex) 최적 우선 탐색(Best First Search) 알고리즘, A* 알고리즘
    - 근사 해법(Approximation Algorithm)
        - 복잡도가 매우 높은 문제에 대해 가장 근사치의 값을 구하는 기법
        - NP-Hard 문제를 해결하기 위해, 주어진 시간에 최적해에 가장 가까운 답을 찾는 결정성 알고리즘을 구현하는 기법
            - NP-Hard : 다항식 시간에 풀기 어렵다고 판단되는 문제
        - 시간 복잡도, 공간 복잡도, 정밀도를 척도로 평가됨
        - ex) 근사 알고리즘
- 시간 복잡도
    - 알고리즘의 실행 시간, 즉 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화한 것으로 시간이 아닌 명령어의 실행 횟수를 표기한 것
    - Big-O Notation
        - 알고리즘의 실행 시간이 최악일 때를 표기하는 방법
        - 실행 횟수는 어떠한 경우에도 표기 수치보다 많을 수 없음
    - Big-gamma Notation
        - 알고리즘의 실행 시간이 평균일 때를 표기하는 방법
        - 실행 횟수는 평균적인 수치로 표기하기 까다로움
    - Big-omega Notation
        - 실행 시간이 최상일 때를 표기하는 방법
        - 실행 횟수는 어떠한 경우에도 표기 수치보다 적을 수 없음
        - 신뢰성이 떨어짐
- 정렬 방식별 알고리즘 복잡도(생략) : p123
- 시간 복잡도에 따른 알고리즘
    - 시간 복잡도는 알고리즘이 문제를 해결하기 위한 시간(연산)의 횟수를 말함
    - 시간 복잡도를 고려하는 것은 최적화를 위해 필요함
    - 알고리즘의 소요 시간에 대한 정확한 평가는 어려워 자료의 수 n이 증가할 때 시간이(Time Complexity) 증가하는 대략적인 패턴을 의미함
    - 시간 복잡도 Big-O 표기법(생략) : p124
4) Mccabe 순환 복잡도(Cyclomatic)
- 순환 복잡도
    - 프로그램의 이해 난이도는 제어 흐름 난이도의 복잡도에 따라 결정되며, 복잡도를 싸이클로메틱 개수에 의해 산정하는 방법
    - 싸이클로메틱의 개수와 원시 프로그램 오류의 개수는 밀접한 관계가 있음
    - 최대 10을 넘지 않도록 하며 넘으면 이를 분해하도록 함
- 복잡도 계산 방식
    - 복잡도=화살표 수-노드 수+2(제어 흐름 그래프를 통해 파악)
    - 복잡도=영역 수(폐 구간)+1(제어 흐름 그래프를 통해 파악)
    - 복잡도=의사 결정수+조건 수+1(프로그램 코드상에서 파악, 제어 프름도를 그리기 어려운 경우 활용)