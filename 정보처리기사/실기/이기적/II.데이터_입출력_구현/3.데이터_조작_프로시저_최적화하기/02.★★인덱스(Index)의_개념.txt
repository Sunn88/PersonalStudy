출제빈도 상
빈출태그 : 인덱스 / 클러스터링 / 로킹

1) 인덱스(Index)
- 물리 데이터베이스 설계에서 성능 향상을 위해 테이블의 컬럼과 레코드를 빠르게 식별할 수 있도록
    컬럼값과 그 값을 포함하는 레코드의 논리적인 주소를 별도의 저장구조를 만들어 저장하는 것
- 인덱스를 이용하면 테이블에 존재하는 데이터 검색 속도를 빠르게 할 수 있음
- 검색 키(Search Key) : 한 파일에서 레코드를 찾는 데 사용되는 속성이나 속성들의 집합
- 인덱스 파일은 인덱스 엔트리(index entry)라고 하는 레코드로 구성됨
    - 인덱스 엔트리 = 인덱스 레코드(index record)

2) 인덱스의 두 가지 기본 종류
- 순서 인덱스(Ordered Index) : 검색키가 값에 대해 정렬된 순서로 되어 있음
- 해시 인덱스(Hash Index) : 검색키가 버킷의 범위 안에서 값이 일정하게 분배되어 있음
    - 값이 할당되는 버킷은 '해시 함수'에 의해 결정됨

3) 클러스터링의 개념
- 비슷한 종류의 무엇인가를 묶는다는 개념
- 특정 컬럼값이 동일한 레코드에서 값에 의한 데이터 조회 시 빠른 속도로 접근하도록
    동일한 장소에 저장하는 방법
- 클러스터 인덱스가 생성되어 여러 레코드에 대해 데이터를 가져올 때 랜덤 접근 방법을 최소화해
    접근 효율성을 높여줌
- 클러스터드 인덱스
    - 정렬 방식 : 인덱스 키 값의 순서에 따라 정렬되어 있으며 데이터 삽입, 삭제 시 
        데이터 재정렬해야 함
    - 검색 속도 : 실제 데이터가 순서대로 저장되어 있어 원하는 데이터를 빠르게 찾을 수 있음
    - 인덱스 생성 : 한 개의 릴레이션에 하나의 인덱스만 생성할 수 있음
    - 리프 페이지 : 실제 데이터
    - 조회성 : 적은 양이든 많은 양이든 유리
    - 사용 용도 : 조회가 많을 때 유리
- 넌 클러스터드 인덱스
    - 정렬 방식 : 키 값만 정렬되어 있으며 실제 데이터는 정렬되지 않음
    - 검색 속도 : 인덱스 검색 후 실제 데이터 위치를 확인해 클러스터드 인덱스에 비해 속도가 느림
    - 인덱스 생성 : 한 개의 릴레이션에 최대 249개까지 생성 가능
    - 리프 페이지 : 실제 데이터 주소
    - 조회성 : 비교적 적은 양의 데이터가 유리
    - 사용 용도 : 삽입, 삭제, 갱신이 많을 떄 유리

4) 밀집 인덱스와 희소 인덱스
- 밀집 인덱스(Dense index)
    - 파일에 있는 모든 검색키 값에 대해 인덱스 레코드가 나타남
    - 각 레코드의 키 값에 대해 인덱스에 엔트리를 유지하는 인덱스
    - 데이터 파일의 각 레코드의 탐색키 값이 인덱스 엔트리에 포함됨
- 희소 인덱스(Sparse index)
    - 인덱스 레코드는 검색키 값에 대해 단지 몇 개만 나타남
    - 레코드가 검색키에 의해 연속적으로 순서되어 있을 때 적절함
    - 일부 키 값에 대해서만 인덱스에 엔트리를 유지하는 인덱스
    - 일반적으로 각 블록마다 한 개의 탐색 키 값이 인덱스 엔트리에 포함됨
- 비교
    - 밀집 인덱스
        - 엔트리 : 각 레코드마다 엔트리를 가짐
        - 엔트리 수 : 밀집 인덱스 내의 엔트리 수는 희소 인덱스 내의 엔트리 수에 
            블록당 평균 레코드 수를 곱한 것
        - 디스크 접근 수 : 질의에서 인덱스가 정의된 애트리뷰트만 검색하는 경우에는
            데이터 파일을 접근할 필요 없이 인덱스만 접근해 질의를 수행할 수 있음
            -> 밀집 인덱스가 희소 인덱스보다 유리함
        - 선택성 : 좋음
    - 희소 인덱스
        - 엔트리 : 각 데이터 블록마다 엔트리를 가짐
        - 엔트리 수 : 레코드의 길이가 블록 크기보다 훨씬 작은 일반적인 경우에는 
            희소 인덱스의 엔트리 수가 밀집 인덱스의 엔트리 수보다 훨씬 적음
        - 디스크 접근 수 : 희소 인덱스는 일반적으로 밀집 인덱스에 비해 인덱스 단계 수가 
            1 정도 적으므로 인덱스 탐색 시 디스크 접근 수가 1 만큼 적을 수 있음
        - 선택성 : 나쁨
* 선택성(Selectivity)
    - 클러스터드 인덱스에서 선택성은 중요한 이슈
    - 클러스터링을 지정할 떄 선택성이 낮은 속성을 기준으로 하지 않는 것이
        데이터베이스 검색 성능 향상에 도움이 됨
- 다단계 인덱스
    - 인덱스 자체가 크다면 인덱스를 탐색하는 시간도 오래 걸릴 수 있음
    - 이를 줄이기 위해 단일 단계 인덱스를 디스크상의 하나의 순서 파일로 간주하고, 
        단일 단계 인덱스에 대해 다시 인덱스를 정의할 수 있음
    - 다단계 인덱스는 가장 상위 단계의 모든 인덱스 엔트리들이 한 블록에 들어갈 수 있을 때까지 
        이 과정을 반복함
    - 가장 상위 인덱스는 '마스터 인덱스' -> 하나의 블록으로 이루어져 있어 주 메모리에 
        상주할 수 있음
    - B+ 트리를 사용함

5) 동시성 제어
- 정의
    - 여러 명의 사용자가 동시에 데이터베이스 하나에 접근할 때 발생하는 여러 가지 문제점을 
        해결하기 위한 제어 방법
    - 다중 사용자 환경에서는 여러 개의 트랜잭션이 섞여서 동시에 실행됨
    - 여러 트랜잭션이 동시에 실행되더라도 트랜잭션이 하나씩 순차적으로 실행된 결과와 
        동일한 경우 : 직렬 가능(Serializable)한 상태
    - 데이터의 무결성 및 일관성 보장을 목표로 함
- 목적
    - 공유도를 최대한으로 함
    - 응답 시간을 빠르게 함
    - 시스템 활용도를 높게 함
- 필요성
    - 트랜잭션의 순차 실행의 결과와 동시 처리된 트랜잭션의 결과가 동일해야 함
    - 직렬화의 가능성을 보장해야 함
    - 여러 사용자가 공유된 데이터베이스에 동시 접근 시 여러 문제가 발생함
        -> 갱신 분실, 불일치, 연쇄 복귀
    - 여러 개의 트랜잭션이 동시에 수행되면 CPU와 디스크의 활용률이 높아져 트랜잭션 처리량이 높아짐
    - 짧은 트랜잭션은 긴 트랜잭션이 모두 완료될 때까지 기다릴 필요가 없으므로 반응시간이 향상됨
    - 트랜잭션의 직렬성이 보장됨
    - 공유도 최대, 응답 시간 최소, 시스템 활용이 최대 보장됨
- 동시성 제어를 하지 않았을 때의 문제점
    - 갱신 분실(Lost update)
        - 2개 이상의 트랜잭션이 같은 데이터를 공유해 갱신할 때 생기는 문제
        - 일련의 갱신 작업 시 일부 갱신 사실이 반영되지 않음
    - 오손 판독(Dirtyread)
        - 애플리케이션이 아직 영구적인 저장소에 커밋되기 전에 데이터베이스로부터 
            데이터를 읽을 때 발생
    - 반복 불능 읽기(Unrepeatable Read)
        - 데이터를 읽고 있는 중에 동시 실행되고 있는 다른 트랜잭션이 데이터를 수정할 경우 
            반복할 수 없는 읽기 문제가 발생함
    - 팬텀(Phantom)
        - 기존에 존재하지 않았던 새로운 데이터가 추가된 경우에 발생
        - 직렬 가능성(Serializable)으로 해결할 수 있음
            - 직렬 가능성
                - 트랜잭션이 연속적으로 실행됨을 보증함
                - 각각의 트랜잭션이 독립적으로 작동함을 의미함(ACID)
                - 엄청난 성능 저하를 초래함
* 트랜잭션의 특성 : ACID
    - 원자성(Atomicity)
        - 완전하게 수행이 완료되지 않으면 전혀 수행되지 않아야 함
        - 연산은 커밋, 롤백을 이용해 적용 또는 취소로 한꺼번에 완료되어야 함
        - 중간에 하나의 오류가 발생되더라도 취소가 되어야 함
    - 일관성(Consistency)
        - 시스템의 고정 요소는 트랜잭션 수행 전후가 같아야 함
        - 트랜잭션 결과는 일관성을 유지해야 함
        - 트랜잭션 처리 전과 후의 데이터베이스 상태는 같아야 함
        - 처리 후라고 해서 구조나 형식이 변경되어서는 안 됨
    - 격리성(Isolation)
        - 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 함
    - 영속성(Durability)
        - 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억되어야 함
- 동시성 제어 기법
    - 2PL(2 Phase Locking) 기법
        - 요청 단계 및 반납 단계로 구성
        - 직렬성 보장, 교착 상태(Dead Lock) 발생 가능
    - 타임스탬프 순서 기법
        - 트랜잭션의 타임스탬프에 따라 순서를 부여하는 기법
        - 시간표가 적은 트랜잭션이 철회, 연쇄복귀(Cascading Rollback)의 부작용이 발생할 수 있음
    - 추후 검증 기법
        - 트랜잭션은 판독, 검증, 기록의 3단계
        - 임시 지역변수 실행, 검증이 성공하면 실제 DB에 반영하고 검증이 실패하면 복귀
            -> 연쇄복귀 방지
* 기아 현상(Starvation)
    - 로킹을 사용할 때 발생하는 교착 상태 외에 또 다른 문제점
    - 어떤 트랜잭션이 무한정 수행되지 않는 반면 시스템에 있는 다른 트랜잭션들은 정상적으로
        수행될 때 발생함
    - 기아 현상을 해결하기 위해 선착 처리(First-come first-served) 큐를 사용함
        - 선착 처리 : 트랜잭션들이 어떤 항목에 락을 요청한 순서에 따라 그 항목에 
            로크(Lock)를 걸 수 있는 방법

6) 로킹(Locking)
- 개념 : 트랜잭션이 사용하는 모든 데이터 항목에 대해 Lock을 지정해 두고, 해당 로크(Lock)를 
    획득한 경우에만 사용 가능하도록 하는 방법
- 로킹의 종류
    - 이진 로크 : 로크가 걸린 상대(Locked:1) 또는 로크가 해제된 상태(Inlocked:0)의 
        두 가지 상태만 존재함
    - 배타적 로크 : 객체를 로크한 트랜잭션에 대해서만 액세스가 예약됨
    - 공유적 로크 : 트랜잭션들이 같은 데이터 항목을 공통적으로 읽어들일 떄 존재함
    - DML 로크 : Select, Insert, Update, Delete 등을 사용해 특정 행에 대한 잠금을 의미함
        -> 특정 테이블 내의 모든 행에 대해 설정되는 테이블 수준의 잠금
    - DDL 로크 : Create, Alter 등을 사용해 객체 구조의 정의를 보호함
    - 내부 잠금 : 공유 데이터 구조, 객체, 파일들에 대해 다중 사용자 접근을 관할하기 위해 사용됨
        - 종류
            - 래치(Latck) : 짧은 시간 동안 유지되는 로크
            - 인큐 : 테이블의 행을 갱신하는 일들에 사용됨
                - 요구가 큐에 줄을 서서 자원을 기다리는 방식
    - 분산 잠금 : 오퍼레이션에서 다양한 노드들에 있는 자원들이 서로 일관성을 보장하기 위해 사용함
    - PCM(Parallel Cache Management) 잠금 : 버퍼 캐시 내부의 하나 이상의 캐시 데이터 블록을 
        여러 데이터베이스 인스턴스들에서 사용할 수 있도록 보호하는 방식
    - 사용자 잠금과 사용자 정의 잠금
- 로킹의 문제
    - 분실 갱신 : 애플리케이션 개발자가 모든 항목을 동시에 갱신하는 것이 쉽다고 판단해 
        특정 항목이 갱신되어도 전체 항목을 갱신하도록 개발했기 때문에 발생
        -> 도구들은 질의한 레코드들에 대해 잠금을 설정해 갱신될 때까지 이를 유지해 
            분실 갱신이 발생하지 않도록 막아줌
    - 블로킹 : 한 세션이 자원에 대해 잠금을 가지는 상태에서 다른 세션이 그 자원을 
        요청하는 경우 발생
        -> 새로 자원을 요청한 세션은 블로킹되어 잠금을 소유한 세션이 잠금을 해제할 때까지 차단됨
    - 교착 상태(Dead lock)가 발생할 수 있음

7) 2단계 로킹(Two-Phase Locking)
- 완벽한 직렬성을 보장하기 위해 로킹 기법을 보다 강화한 방법
    - 비관적 잠금 : 어떤 값을 변경하기 직전에 동작하기 시작
        -> 대부분 충돌을 일으킨다는 가정 하에 실행됨
    - 낙관적 잠금 : 대부분 충돌을 일으키지 않는다는 가정하에 트랜잭션이 완료될 때까지 
        제한없이 실행됨
- 2가지 단계로 이루어짐 -> 확장 단계 후 수축 단계를 실행하고 서로 중복되거나 겹칠 수 없음
    - 확장 단계(Growing Phase) : 항목들에 대한 새로운 로크를 획득할 수 있지만 해제할 수 없음
    - 수축 단계(Shrinking Phase) : 이미 보유하고 있는 로크들을 해제할 수 있지만 어떤 새로운 
        로크를 획득할 수 없음
- 교착 상태가 발생할 수 있음